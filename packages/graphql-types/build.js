module.exports=function(n){var t={};function e(a){if(t[a])return t[a].exports;var i=t[a]={i:a,l:!1,exports:{}};return n[a].call(i.exports,i,i.exports,e),i.l=!0,i.exports}return e.m=n,e.c=t,e.d=function(n,t,a){e.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:a})},e.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},e.t=function(n,t){if(1&t&&(n=e(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var a=Object.create(null);if(e.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var i in n)e.d(a,i,function(t){return n[t]}.bind(null,i));return a},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},e.p="",e(e.s=1)}([function(n,t){n.exports='type Query\n\ntype Mutation\n\nschema {\n  query: Query\n  mutation: Mutation\n}\n\nenum AccountType {\n  CHECKING\n  SAVINGS\n  LOAN\n  CREDIT_CARD\n  LINE_OF_CREDIT\n  MORTGAGE\n  INVESTMENT\n  PRE_PAID_CARD\n  CERTIFICATE\n}\n\ninterface Account {\n  """\n  The account ID is a persistent and unique identifier for the account.\n  It must be unique for all users across the institution and remain the\n  same over the life of the account.\n  """\n  id: ID!\n  """\n  The account number (or a masked portion there-of) will be displayed to the\n  user. Like the ID, it must be unique for all users across the institution\n  and remain the same over the life of the account. It may contain a prefix to\n  define the Account Type for consumption, such as SV-1234 or IL-1234.\n  """\n  accountNumber: String\n  """\n  The account name is the textual representation of the account. This\n  value is visible to the user and must be human-readable.\n  """\n  name: String\n  type: AccountType\n  """\n  Negative, zero or positive amount. If this is a loan, any balance owed to\n  the financial institution will show as a positive amount. If this is a\n  deposit product, if the product is overdrawn it will be a negative amount.\n  Positive is assumed if the sign does not appear in the data.\n  """\n  actualBalance: Float\n  """\n  Negative, zero or positive amount. If this is a loan, any balance owed\n  to the financial institution will show as a positive amount. If this is\n  a deposit product, if the product is overdrawn it will be a negative amount.\n  Positive is assumed if the sign does not appear in the data.\n  """\n  availableBalance: Float\n  """\n  The transactions for this account\n  """\n  transactions(limit: Int = 10, categoryId: ID, query: String): [Transaction!]!\n}\n\ninterface InterestBearingAccount {\n  apy: Float\n}\n\ntype CheckingAccount implements Account & InterestBearingAccount {\n  id: ID!\n  accountNumber: String\n  name: String\n  type: AccountType\n  actualBalance: Float\n  availableBalance: Float\n  routingNumber: String\n  transactions(limit: Int = 10, categoryId: ID, query: String): [Transaction!]!\n  apy: Float\n}\n\ntype SavingsAccount implements Account & InterestBearingAccount {\n  id: ID!\n  accountNumber: String\n  name: String\n  type: AccountType\n  actualBalance: Float\n  availableBalance: Float\n  routingNumber: String\n  transactions(limit: Int = 10, categoryId: ID, query: String): [Transaction!]!\n  """\n  Number of remaining transactions according to [Reg D](https://en.wikipedia.org/wiki/Regulation_D_(FRB)).\n  """\n  regDRemaining: Int\n  apy: Float\n}\n\ntype CertificateAccount implements Account & InterestBearingAccount {\n  id: ID!\n  accountNumber: String\n  name: String\n  type: AccountType\n  actualBalance: Float\n  availableBalance: Float\n  routingNumber: String\n  transactions(limit: Int = 10, categoryId: ID, query: String): [Transaction!]!\n  apy: Float\n}\n\ntype InvestmentAccount implements Account {\n  id: ID!\n  accountNumber: String\n  name: String\n  type: AccountType\n  actualBalance: Float\n  availableBalance: Float\n  routingNumber: String\n  transactions(limit: Int = 10, categoryId: ID, query: String): [Transaction!]!\n}\n\ntype LoanPayment {\n  nextDueDate: Date\n  amount: Float\n}\n\ninterface AbstractLoanAccount {\n  apr: Float\n  nextPayment: LoanPayment\n  originationDate: Date\n  payoff: Float\n  secured: Boolean\n}\n\ntype LoanAccount implements Account & AbstractLoanAccount {\n  id: ID!\n  accountNumber: String\n  name: String\n  type: AccountType\n  actualBalance: Float\n  availableBalance: Float\n  routingNumber: String\n  transactions(limit: Int = 10, categoryId: ID, query: String): [Transaction!]!\n  apr: Float\n  nextPayment: LoanPayment\n  originationDate: Date\n  secured: Boolean\n  payoff: Float\n}\n\ninterface OpenLoanAccount {\n  limit: Float\n}\n\ntype LineOfCreditAccount implements Account & AbstractLoanAccount & OpenLoanAccount {\n  id: ID!\n  accountNumber: String\n  name: String\n  type: AccountType\n  actualBalance: Float\n  availableBalance: Float\n  routingNumber: String\n  transactions(limit: Int = 10, categoryId: ID, query: String): [Transaction!]!\n  apr: Float\n  nextPayment: LoanPayment\n  limit: Float\n  secured: Boolean\n  originationDate: Date\n  payoff: Float\n}\n\ntype CreditCardAccount implements Account & AbstractLoanAccount & OpenLoanAccount {\n  id: ID!\n  accountNumber: String\n  name: String\n  type: AccountType\n  actualBalance: Float\n  availableBalance: Float\n  routingNumber: String\n  transactions(limit: Int = 10, categoryId: ID, query: String): [Transaction!]!\n  apr: Float\n  nextPayment: LoanPayment\n  limit: Float\n  secured: Boolean\n  originationDate: Date\n  payoff: Float\n}\n\nextend type Query {\n  account(id: ID!): Account\n}\n\nenum AddressType {\n  HOME\n  MAILING\n  WORK\n  TEMPORARY\n  PREVIOUS\n}\n\ninput AddressInput {\n  street1: String!\n  street2: String\n  city: String!\n  state: String!\n  zipCode: String!\n}\n\ntype Address {\n  type: AddressType\n  street1: String!\n  street2: String\n  city: String!\n  state: String!\n  zipCode: String!\n}\n\nenum ContactType {\n  ADDRESS\n  PHONE\n  EMAIL\n}\n\ninterface ContactPoint {\n  type: ContactType\n}\n\ntype ContactAddress implements ContactPoint {\n  type: ContactType\n  address: Address\n}\n\nenum PhoneType {\n  HOME\n  WORK\n  MOBILE\n  PAGER\n  FAX\n  OTHER\n}\n\ntype ContactPhone implements ContactPoint {\n  type: ContactType\n  phoneType: PhoneType!\n  number: String!\n  extension: String\n  description: String\n  """\n  Phone number is registered to receive SMS messages.\n  """\n  smsRegistered: Boolean\n}\n\nenum EmailType {\n  HOME\n  WORK\n  OTHER\n}\n\ntype ContactEmail implements ContactPoint {\n  type: ContactType\n  emailType: EmailType!\n  emailAddress: String!\n}\n\n"""\nThis identifies that appropriate access has been demonstrated to receive information\nelectronically for the associated contact point.\n"""\ntype DemonstratedAccess {\n  dateTime: Date!\n  userId: ID!\n}\n\ntype Contact implements Node {\n  id: ID!\n  type: ContactType\n  contactPoint: ContactPoint!\n  demonstratedAccess: DemonstratedAccess\n}\n\nextend type Mutation {\n  updateContact(id: ID!, address: AddressInput): Contact\n}\n\ninterface Node {\n  id: ID!\n}\n\nextend type Query {\n  node(id: ID!, type: String!): Node\n}\n\n"""\nThe Party defines all the fields necessary to define a person or organization related to a financial institution.\n"""\ninterface Party {\n  id: ID!\n  accounts: [Account]\n  contacts: [Contact]\n}\n\ntype Person implements Party {\n  id: ID!\n  accounts: [Account]\n  """\n  List of how the person can be contacted\n  """\n  contacts: [Contact]\n  firstName: String!\n  lastName: String!\n}\n\ntype Organization implements Party {\n  id: ID!\n  accounts: [Account]\n  """\n  List of how the organization can be contacted\n  """\n  contacts: [Contact]\n  name: String!\n}\n\nextend type Mutation {\n  """\n  Update the address associated with the current user\n  """\n  updateAddress(type: String, address: AddressInput!): Address\n  """\n  Update the address for a specific party\n  """\n  updatePartyAddress(partyId: ID!, type: String, address: AddressInput!): Address\n}\n\nscalar Date\n\ntype Category {\n  id: ID!\n  name: String!\n}\n\ntype Merchant {\n  id: ID!\n  name: String!\n}\n\nenum TransactionStatus {\n  POSTED\n  PENDING\n  DENIED\n  VOID\n}\n\nenum TransactionType {\n  CREDIT\n  DEBIT\n}\n\ntype Message {\n  messageMarkdown: String\n  url: String\n}\n\ntype Transaction {\n  """\n  The transaction ID is a persistent and unique identifier for each\n  transaction. It must be unique within the account as it is used for matching\n  purposes. Transactions should always be returned with the same ID, even if\n  transactional information has changed (type, amount, description, date,\n  etc.) since the previous account data pull.\n  """\n  id: ID!\n  """\n  The date/time posted is the date the transaction was posted to the account.\n  If this date is unavailable, it is acceptable to use the date that the\n  transaction took place\n  """\n  date: Date!\n  """\n  The description represents the memo of the transaction.\n  """\n  description: String!\n  """\n  The transaction amount should always be the absolute value of the\n  transaction. The sign of the amount will be determined based on the\n  transaction type.\n  """\n  amount: Float!\n  """\n  The transaction type simply reflects whether the account was debited or\n  credited. For comment-only transactions, the value can be either Debit or\n  Credit and the transaction amount can be null, not return or 0.00.\n  """\n  type: TransactionType!\n  """\n  The running balance of this transaction\'s account.\n  """\n  balance: Float\n  """\n  The current status of the transaction. This may be part of a session or\n  after the session has ended.\n  """\n  status: TransactionStatus\n  category: Category\n  merchant: Merchant\n  message: Message\n  account: Account\n}\n\nextend type Query {\n  category(id: ID): Category\n  transaction(id: ID!): Transaction\n}\n\ntype User {\n  """\n  The user ID is persistent and unique across the institution and remains the\n  same over the life of the user.\n  """\n  id: ID!\n  accounts: [Account]\n  party: Party\n}\n\nextend type Query {\n  me: User\n}\n'},function(n,t,e){"use strict";e.r(t);var a=e(0),i=e.n(a);e.d(t,"default",function(){return i.a})}]);